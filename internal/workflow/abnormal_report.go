package workflow

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/garyjia/ai-reimbursement/internal/models"
	"github.com/garyjia/ai-reimbursement/internal/repository"
	"go.uber.org/zap"
)

// AbnormalReportHandler handles flagging and reporting of abnormal reimbursement items
// ARCH-001 Enhancement: Route items exceeding confidence thresholds for manual review
type AbnormalReportHandler struct {
	historyRepo     *repository.HistoryRepository
	instanceRepo    *repository.InstanceRepository
	accountantEmail string
	logger          *zap.Logger
}

// NewAbnormalReportHandler creates a new abnormal report handler
func NewAbnormalReportHandler(
	historyRepo *repository.HistoryRepository,
	instanceRepo *repository.InstanceRepository,
	accountantEmail string,
	logger *zap.Logger,
) *AbnormalReportHandler {
	return &AbnormalReportHandler{
		historyRepo:     historyRepo,
		instanceRepo:    instanceRepo,
		accountantEmail: accountantEmail,
		logger:          logger,
	}
}

// AbnormalReport represents a flagged abnormal reimbursement item
type AbnormalReport struct {
	InstanceID      int64
	ItemID          int64
	ReportType      string // CONFIDENCE_THRESHOLD, POLICY_VIOLATION, PRICE_OUTLIER
	Severity        string // LOW, MEDIUM, HIGH, CRITICAL
	ConfidenceScore float64
	Threshold       float64
	Violations      []string
	Rationale       string
	FlaggedAt       time.Time
	AccountantEmail string
}

// FlagAbnormalItem flags an item as abnormal and sends report to accountant
// Returns error if notification fails, but logs rather than blocking the workflow
func (arh *AbnormalReportHandler) FlagAbnormalItem(
	ctx context.Context,
	instance *models.ApprovalInstance,
	report *AbnormalReport,
) error {
	report.FlaggedAt = time.Now()
	report.AccountantEmail = arh.accountantEmail

	arh.logger.Warn("Flagging abnormal reimbursement item",
		zap.Int64("instance_id", instance.ID),
		zap.Int64("item_id", report.ItemID),
		zap.String("report_type", report.ReportType),
		zap.String("severity", report.Severity),
		zap.Float64("confidence_score", report.ConfidenceScore))

	// Log to audit trail (if repository is available)
	if arh.historyRepo != nil {
		auditData, _ := json.Marshal(report)
		err := arh.historyRepo.Create(nil, &models.ApprovalHistory{
			InstanceID:     instance.ID,
			PreviousStatus: instance.Status,
			NewStatus:      models.StatusInReview, // Flag for manual review
			ActionType:     "ABNORMAL_ITEM_FLAGGED",
			ActionData:     string(auditData),
			Timestamp:      time.Now(),
		})

		if err != nil {
			arh.logger.Error("Failed to record abnormal item in audit trail",
				zap.Error(err),
				zap.Int64("instance_id", instance.ID))
			// Don't fail - continue with notification attempt
		}
	} else {
		arh.logger.Debug("History repository not available, skipping audit trail record")
	}

	// Send notification to accountant
	// For now, echo to console; actual email implementation done separately
	if err := arh.notifyAccountant(ctx, report); err != nil {
		arh.logger.Error("Failed to notify accountant of abnormal item",
			zap.Error(err),
			zap.String("email", report.AccountantEmail))
		// Log but don't block - notification is best-effort
		return nil // Return nil to not block workflow
	}

	arh.logger.Info("Successfully flagged and notified abnormal item",
		zap.Int64("instance_id", instance.ID),
		zap.String("severity", report.Severity))

	return nil
}

// notifyAccountant sends abnormal report notification to accountant email
// Current implementation: Echo to console
// TODO: Integrate with email component when ready
func (arh *AbnormalReportHandler) notifyAccountant(ctx context.Context, report *AbnormalReport) error {
	// Build notification message
	message := arh.buildNotificationMessage(report)

	// CONSOLE OUTPUT (for development/testing)
	arh.printAbnormalReportToConsole(message, report)

	// TODO: Integrate with email sender when component is ready
	// err := arh.emailSender.Send(ctx, &email.Message{
	//     To:      report.AccountantEmail,
	//     Subject: fmt.Sprintf("‚ö†Ô∏è  ABNORMAL REIMBURSEMENT REPORT [%s]", report.Severity),
	//     Body:    message,
	// })

	return nil
}

// buildNotificationMessage builds the notification message for accountant
func (arh *AbnormalReportHandler) buildNotificationMessage(report *AbnormalReport) string {
	violations := ""
	for i, v := range report.Violations {
		violations += fmt.Sprintf("    %d. %s\n", i+1, v)
	}

	message := fmt.Sprintf(`
Abnormal Reimbursement Item Report [%s]
========================================

Instance ID:        %d
Item ID:            %d
Report Type:        %s
Severity:           %s
Flagged Time:       %s

Confidence Analysis:
  Score:            %.2f (%.0f%%)
  Threshold:        %.2f
  Status:           %s

%s

Violations Detected:
%s

Rationale:
  %s

Action Required:
  Please review this item manually in the Lark approval workflow.
  The item has been flagged for manual verification before processing.

Report Generated By: AI Reimbursement System
Accountant Email:   %s
`, report.Severity, report.InstanceID, report.ItemID, report.ReportType, report.Severity, report.FlaggedAt.Format("2006-01-02 15:04:05"),
		report.ConfidenceScore, report.ConfidenceScore*100, report.Threshold,
		detectStatus(report.ConfidenceScore, report.Threshold),
		arh.buildConfidenceDetails(report),
		violations,
		report.Rationale,
		report.AccountantEmail)

	return message
}

// buildConfidenceDetails provides detailed confidence analysis
func (arh *AbnormalReportHandler) buildConfidenceDetails(report *AbnormalReport) string {
	diff := report.ConfidenceScore - report.Threshold
	diffPercent := (diff / report.Threshold) * 100

	status := ""
	if diff < 0 {
		status = fmt.Sprintf("  Below Threshold:  %.4f (%.1f%% below)", -diff, -diffPercent)
	} else {
		status = fmt.Sprintf("  Above Threshold:  %.4f (%.1f%% above)", diff, diffPercent)
	}

	return status
}

// detectStatus determines if item is above/below threshold
func detectStatus(score, threshold float64) string {
	if score >= threshold {
		return "ABOVE_THRESHOLD - Should auto-approve"
	}
	return "BELOW_THRESHOLD - Requires manual review"
}

// printAbnormalReportToConsole outputs the report to console for development
func (arh *AbnormalReportHandler) printAbnormalReportToConsole(message string, report *AbnormalReport) {
	// Color-coded console output based on severity
	severitySymbol := map[string]string{
		"LOW":      "‚ö™",
		"MEDIUM":   "üü°",
		"HIGH":     "üî¥",
		"CRITICAL": "‚ùå",
	}

	symbol := severitySymbol[report.Severity]
	if symbol == "" {
		symbol = "‚ö†Ô∏è"
	}

	fmt.Printf("\n")
	fmt.Printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n")
	fmt.Printf("‚ïë %s  ABNORMAL REIMBURSEMENT REPORT [%s]                          ‚ïë\n", symbol, report.Severity)
	fmt.Printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n")
	fmt.Printf("‚ïë                                                                    ‚ïë\n")

	// Print key details
	fmt.Printf("‚ïë  Instance ID:         %-43d  ‚ïë\n", report.InstanceID)
	fmt.Printf("‚ïë  Item ID:             %-43d  ‚ïë\n", report.ItemID)
	fmt.Printf("‚ïë  Report Type:         %-43s  ‚ïë\n", report.ReportType)
	fmt.Printf("‚ïë  Flagged Time:        %-43s  ‚ïë\n", report.FlaggedAt.Format("15:04:05"))
	fmt.Printf("‚ïë                                                                    ‚ïë\n")
	fmt.Printf("‚ïë  Confidence Score:    %-6.2f  /  Threshold: %-6.2f              ‚ïë\n", report.ConfidenceScore, report.Threshold)

	if report.ConfidenceScore >= report.Threshold {
		fmt.Printf("‚ïë  Status:              ‚úì ABOVE THRESHOLD (auto-approve ready)         ‚ïë\n")
	} else {
		fmt.Printf("‚ïë  Status:              ‚úó BELOW THRESHOLD (manual review needed)     ‚ïë\n")
	}

	fmt.Printf("‚ïë                                                                    ‚ïë\n")

	// Print violations
	if len(report.Violations) > 0 {
		fmt.Printf("‚ïë  Violations:                                                       ‚ïë\n")
		for i, v := range report.Violations {
			// Truncate long violations to fit in 60 chars
			violation := v
			if len(violation) > 55 {
				violation = violation[:52] + "..."
			}
			fmt.Printf("‚ïë    %d. %-56s  ‚ïë\n", i+1, violation)
		}
		fmt.Printf("‚ïë                                                                    ‚ïë\n")
	}

	// Print rationale (truncated)
	fmt.Printf("‚ïë  Rationale:                                                        ‚ïë\n")
	rationale := report.Rationale
	// Split into lines of max 60 chars
	for len(rationale) > 60 {
		fmt.Printf("‚ïë    %s  ‚ïë\n", rationale[:60])
		rationale = rationale[60:]
	}
	if rationale != "" {
		fmt.Printf("‚ïë    %s  ‚ïë\n", rationale)
	}

	fmt.Printf("‚ïë                                                                    ‚ïë\n")
	fmt.Printf("‚ïë  üìß Notification sent to: %-38s  ‚ïë\n", report.AccountantEmail)
	fmt.Printf("‚ïë                                                                    ‚ïë\n")
	fmt.Printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n")
	fmt.Printf("\n")

	// Also print to logger for structured logging
	arh.logger.Info("Abnormal Report Output",
		zap.String("message", message),
		zap.String("severity", report.Severity),
		zap.Int64("instance_id", report.InstanceID))
}

// CreateAbnormalReportFromConfidence creates an abnormal report from confidence score
func CreateAbnormalReportFromConfidence(
	instanceID, itemID int64,
	confidenceScore, threshold float64,
	violations []string,
	rationale string,
) *AbnormalReport {
	severity := determineSeverity(confidenceScore, threshold)

	return &AbnormalReport{
		InstanceID:      instanceID,
		ItemID:          itemID,
		ReportType:      "CONFIDENCE_THRESHOLD",
		Severity:        severity,
		ConfidenceScore: confidenceScore,
		Threshold:       threshold,
		Violations:      violations,
		Rationale:       rationale,
	}
}

// determineSeverity determines report severity based on confidence score
func determineSeverity(confidenceScore, threshold float64) string {
	diff := threshold - confidenceScore // How far below threshold

	if confidenceScore >= threshold {
		return "LOW" // Above threshold, not really abnormal
	}

	if diff < 0.05 { // Within 5% of threshold
		return "LOW"
	} else if diff < 0.15 { // Within 15% of threshold
		return "MEDIUM"
	} else if diff < 0.30 { // Within 30% of threshold
		return "HIGH"
	}

	return "CRITICAL" // More than 30% below threshold
}
